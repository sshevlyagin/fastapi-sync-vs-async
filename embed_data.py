#!/usr/bin/env python3
"""
Script to embed CSV data directly into the HTML dashboard file.
This eliminates the need for a web server to serve CSV files.
"""

import csv
import json
import sys
from pathlib import Path


def read_csv_to_dict(file_path):
    """Read a CSV file and return it as a list of dictionaries."""
    data = []
    with open(file_path, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            # Convert numeric values
            converted_row = {}
            for key, value in row.items():
                if value == '':
                    converted_row[key] = None
                else:
                    try:
                        # Try to convert to float first
                        if '.' in value:
                            converted_row[key] = float(value)
                        else:
                            # Try integer
                            converted_row[key] = int(value)
                    except (ValueError, AttributeError):
                        # Keep as string
                        converted_row[key] = value
            data.append(converted_row)
    return data


def collect_all_data():
    """Collect all CSV data from the results directory."""
    results_dir = Path('results')

    if not results_dir.exists():
        print(f"Error: {results_dir} directory not found!")
        sys.exit(1)

    route_configs = [
        'async-route-async-inner-async-bg-async-task',
        'async-route-async-inner-async-bg-sync-task',
        'async-route-async-inner-sync-bg-sync-task',
        'async-route-sync-inner-async-bg-async-task',
        'sync-route-sync-inner-async-bg-async-task',
        'sync-route-sync-inner-async-bg-sync-task',
        'sync-route-sync-inner-sync-bg-sync-task'
    ]

    user_counts = [10, 40, 100]

    all_data = {}

    for route in route_configs:
        for users in user_counts:
            stats_file = results_dir / f"{route}-{users}users_stats.csv"
            resources_file = results_dir / f"{route}-{users}users_resources.csv"

            key = f"{route}-{users}users"

            if not stats_file.exists() or not resources_file.exists():
                print(f"Warning: Missing files for {key}")
                continue

            all_data[key] = {
                'stats': read_csv_to_dict(stats_file),
                'resources': read_csv_to_dict(resources_file)
            }
            print(f"✓ Loaded {key}")

    return all_data


def embed_data_in_html(html_path, output_path, data):
    """Embed the CSV data into the HTML file."""
    with open(html_path, 'r', encoding='utf-8') as f:
        html_content = f.read()

    # Convert data to JSON string
    data_json = json.dumps(data, indent=2)

    # Create the embedded data script
    embedded_data_script = f"""
  <script id="embedded-data">
    // Embedded CSV data - generated by embed_data.py
    const EMBEDDED_DATA = {data_json};
  </script>"""

    # Find the position right after <body> tag and insert the data
    body_pos = html_content.find('<body>')
    if body_pos == -1:
        print("Error: Could not find <body> tag in HTML")
        sys.exit(1)

    body_end_pos = html_content.find('>', body_pos) + 1
    html_content = html_content[:body_end_pos] + embedded_data_script + html_content[body_end_pos:]

    # Replace the parseCSV function to use embedded data instead
    old_parse_csv = """    function parseCSV(filePath) {
      return new Promise((resolve, reject) => {
        Papa.parse(filePath, {
          download: true,
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          complete: (results) => resolve(results.data),
          error: (error) => reject(error)
        });
      });
    }"""

    new_parse_csv = """    function parseCSV(filePath) {
      // Use embedded data instead of fetching CSV files
      return new Promise((resolve, reject) => {
        // Extract the key from the file path (e.g., "results/route-10users_stats.csv" -> "route-10users")
        const match = filePath.match(/results\\/(.+?)_(stats|resources)\\.csv$/);
        if (!match) {
          reject(new Error(`Invalid file path format: ${filePath}`));
          return;
        }

        const key = match[1];
        const type = match[2];

        if (!EMBEDDED_DATA[key]) {
          reject(new Error(`No embedded data found for: ${key}`));
          return;
        }

        const data = EMBEDDED_DATA[key][type];
        if (!data) {
          reject(new Error(`No ${type} data found for: ${key}`));
          return;
        }

        resolve(data);
      });
    }"""

    html_content = html_content.replace(old_parse_csv, new_parse_csv)

    # Remove the PapaParse script tag since we don't need it anymore
    # Actually, let's keep it commented out in case someone wants to revert
    html_content = html_content.replace(
        '<script src="https://cdn.jsdelivr.net/npm/papaparse@5"></script>',
        '<!-- PapaParse not needed with embedded data -->\n  <!-- <script src="https://cdn.jsdelivr.net/npm/papaparse@5"></script> -->'
    )

    # Write the updated HTML
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(html_content)

    print(f"\n✓ Embedded data written to {output_path}")


def main():
    """Main function."""
    html_path = Path('load-test-dashboard.html')

    if not html_path.exists():
        print(f"Error: {html_path} not found!")
        sys.exit(1)

    print("Collecting CSV data...")
    data = collect_all_data()

    print(f"\nCollected data for {len(data)} configurations")

    print("\nEmbedding data into HTML...")
    embed_data_in_html(html_path, html_path, data)

    print("\n✅ Done! The dashboard now has embedded data and can be opened directly in a browser.")
    print(f"   Just open {html_path} in your browser - no server needed!")


if __name__ == '__main__':
    main()
